# 1. Initial Setup (Both Users)

**Both Alice and Bob must first register accounts:**

## Alice's Registration (`POST /api/auth/register`)

```json
{
  "username": "alice",
  "auth_password": "AliceSecurePassword123!",
  "email": "alice@example.com",
  "public_key": "LS0tLS1CRUdJTi...", // Base64(PEM X25519 public key)
  "signing_public_key": "LS0tLS1CRUdJTi...", // Base64(PEM Ed25519 public key)
  "iv_KEK": "randomIV123...",
  "encrypted_KEK": "encryptedKEK456...",
  "salt": "salt789...",
  "p": 1, "m": 12288, "t": 3
}
```

### Bob's Registration (similar format)

Bob registers with his own X25519 + Ed25519 keypairs and KEK.

## 2. Alice Uploads a File

**Alice uploads an encrypted file (`POST /api/files`):**

### Client-side (Alice's device)

1. Alice selects `document.pdf` to upload
2. **Generates random DEK**: `dek = random_32_bytes()`
3. **Generates IVs**:
   - `iv_file = SHA256(owner_id + shared_user_id + file_id + smth random) truncated to 12 bytes` (for file encryption)
   - `iv_dek = SHA 256(filename + userid + smth random ) truncated to 12 bytes` (for DEK encryption)
4. **Retrieves KEK**: `KEK = AES_GCM_decrypt(encrypted_KEK, password_key, iv_KEK)`
5. **Encrypts file**: `encrypted_file = AES_GCM_encrypt(file_data, dek, iv_file)`
6. **Derives password key**: `password_key = Argon2id(alice_password, salt, params)`
7. **Encrypts DEK**: `encrypted_dek = AES_GCM_encrypt(dek, KEK, iv_dek)`

### Request to server

```http
POST /api/files
Authorization: Bearer <alice_jwt_token>
Content-Type: multipart/form-data
X-File-Name: document.pdf
X-File-Type: pdf
X-File-Size: 524288
X-IV-File: base64(iv_file)
X-IV-DEK: base64(iv_dek)
X-Encrypted-DEK: base64(encrypted_dek)

encrypted_file: <binary encrypted file data>
```

### Server response

```json
{
  "message": "File uploaded successfully",
  "file_id": "abc123-def456-ghi789",
  "file_name": "document.pdf"
}
```

## 3. Alice Initiates Sharing with Bob

### Step 3a: Get Bob's Public Keys (`GET /api/shares/public-key/bob`)

**Alice's client requests Bob's public keys:**

```http
GET /api/shares/public-key/bob
Authorization: Bearer <alice_jwt_token>
```

**Server response:**

```json
{
  "username": "bob",
  "user_id": "bob-user-id-456",
  "x25519_public_key": "-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VuAyEA...\n-----END PUBLIC KEY-----",
  "ed25519_public_key": "-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VwAyEA...\n-----END PUBLIC KEY-----",
  "tofu_message": "Key trusted on first use"
}
```

### Step 3b: Alice's Client Performs Cryptographic Operations

**On Alice's device, the client:**

1. **Loads Alice's private keys** (from secure storage/user input)
2. **Retrieves the original file** by downloading from `/api/files/document.pdf`
3. **Decrypts the file locally** using Alice's KEK and DEK
4. **Generates ephemeral X25519 keypair**:

   ```python
   from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey, X25519PublicKey
   ephemeral_private = X25519PrivateKey.generate()
   ephemeral_public = ephemeral_private.public_key()
   ```

5. **Performs dual ECDH**:

   ```python
   from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey, X25519PublicKey
   bob_x25519_public = X25519PublicKey.from_public_bytes(base64.decode(bob_x25519_public_key))
   secret1 = ECDH(ephemeral_private, bob_x25519_public)
   secret2 = ECDH(alice_x25519_private, bob_x25519_public)
   ```

6. **Derives shared AES key**:

   ```python
   from hashlib import sha256
   combined_secret = secret1 || secret2
   aes_key = SHA256(combined_secret)[:32]
   ```

7. **Encrypts file for Bob**:

   ```python
   from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
   # Nonce Generation Algorithm
   # 
   # The nonce is generated by concatenating Bob's user ID, the timestamp when Alice's KEK was created, and a random padding value. This concatenated value is then hashed using SHA256, and the first 12 bytes of the hash are used as the nonce.
   #
   # Pseudocode:
   #
   #   bob_id = "bob-user-id-456"
   #   kek_created_at = "2024-01-10T09:00:00Z"  # ISO8601 string
   #   random_padding = random_bytes(16)
   #   data = bob_id.encode() + kek_created_at.encode() + random_padding
   #   nonce = SHA256(data)[:12]
   #
   # Python example:
   import os
   from hashlib import sha256

   bob_id = b"bob-user-id-456"
   kek_created_at = b"2024-01-10T09:00:00Z"
   random_padding = os.urandom(16)
   data = bob_id + kek_created_at + random_padding
   nonce = sha256(data).digest()[:12]
   encrypted_file_for_bob = AES_GCM_encrypt(decrypted_file, aes_key, nonce)
   ```

8. **Creates signature**:

   ```python
   from cryptography.hazmat.primitives.asymmetric import ed25519
   signature_data = ephemeral_public_bytes || nonce || encrypted_file_for_bob
   signature = Ed25519_sign(alice_ed25519_private, signature_data)
   ```

### Step 3c: Share the File (`POST /api/shares/abc123-def456-ghi789/share`)

**Alice's client sends the encrypted share:**

```json
{
  "shared_with_username": "bob",
  "encrypted_file": "base64(encrypted_file_for_bob)",
  "nonce": "base64(nonce)",
  "ephemeral_public_key": "base64(ephemeral_public_bytes)",
  "signature": "base64(signature)"
}
```

**Server response:**

```json
{
  "message": "File shared successfully",
  "share_id": "share-789-xyz",
  "shared_with": "bob-user-id-456",
  "tofu_message": "Key verified successfully"
}
```

## 4. Bob Receives and Downloads the Shared File

### Step 4a: Bob Lists Files Shared With Him (`GET /api/shares/shared-with-me`)

```http
GET /api/shares/shared-with-me
Authorization: Bearer <bob_jwt_token>
```

**Response:**

```json
{
  "files": [
    {
      "share_id": "share-789-xyz",
      "file_id": "abc123-def456-ghi789",
      "file_name": "document.pdf",
      "file_type": "pdf",
      "file_size": 524288,
      "shared_by": "alice-user-id-123",
      "shared_by_username": "alice",
      "created_at": "2024-01-15T10:30:00Z"
    }
  ],
  "count": 1
}
```

### Step 4a-alt: Alice Lists Files She Has Shared (`GET /api/shares/shared-by-me`)

```http
GET /api/shares/shared-by-me
Authorization: Bearer <alice_jwt_token>
```

**Response:**

```json
{
  "files": [
    {
      "share_id": "share-789-xyz",
      "file_id": "abc123-def456-ghi789",
      "file_name": "document.pdf",
      "file_type": "pdf",
      "file_size": 524288,
      "shared_with": "bob-user-id-456",
      "shared_with_username": "bob",
      "created_at": "2024-01-15T10:30:00Z"
    }
  ],
  "count": 1
}
```

### Step 4b: Bob Downloads the Encrypted Data (`GET /api/shares/download/share-789-xyz`)

```http
GET /api/shares/download/share-789-xyz
Authorization: Bearer <bob_jwt_token>
```

**Server response:**

```json
{
  "file_id": "abc123-def456-ghi789",
  "file_name": "document.pdf",
  "file_type": "pdf",
  "file_size": 524288,
  "shared_by": "alice-user-id-123",
  "shared_by_username": "alice",
  "encrypted_file": "base64(encrypted_file_for_bob)",
  "nonce": "base64(nonce)",
  "ephemeral_public_key": "base64(ephemeral_public_bytes)",
  "sender_signature": "base64(signature)",
  "sender_x25519_public_key": "-----BEGIN PUBLIC KEY-----\n...",
  "sender_ed25519_public_key": "-----BEGIN PUBLIC KEY-----\n...",
  "created_at": "2024-01-15T10:30:00Z"
}
```

### Step 4c: Bob's Client Decrypts the File

**On Bob's device, the client:**

1. **Loads Bob's X25519 private key** (from secure storage/user input)
2. **Loads Alice's public keys** (from the response)
3. **Reconstructs ephemeral public key**:

   ```python
   from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PublicKey
   ephemeral_public = X25519PublicKey.from_public_bytes(base64.decode(ephemeral_public_key))
   ```

4. **Verifies signature**:

   ```python
   from cryptography.hazmat.primitives.asymmetric import ed25519
   alice_ed25519_public = ed25519.Ed25519PublicKey.from_public_bytes(base64.decode(alice_ed25519_public_key))
   signature_data = ephemeral_public_bytes || nonce || encrypted_file
   Ed25519_verify(alice_ed25519_public, signature, signature_data)
   ```

5. **Performs dual ECDH** (same as Alice, but with Bob's private key):

   ```python
   from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey, X25519PublicKey
   secret1 = ECDH(bob_x25519_private, ephemeral_public)
   secret2 = ECDH(bob_x25519_private, alice_x25519_public)
   ```

6. **Derives the same AES key**:

   ```python
   from hashlib import sha256
   combined_secret = secret1 || secret2
   aes_key = SHA256(combined_secret)[:32]
   ```

7. **Decrypts the file**:

   ```python
   from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
   decrypted_file = AES_GCM_decrypt(encrypted_file, aes_key, nonce)
   ```

8. **Saves `document.pdf`** to Bob's device

## Security Properties Achieved

✅ **Confidentiality**: Only Bob can decrypt the file (dual ECDH with his private key)
✅ **Authenticity**: Bob can verify Alice sent it (Ed25519 signature verification)
✅ **Forward Secrecy**: Even if long-term keys are compromised later, this specific file remains secure (ephemeral key is discarded)

## Key Server Role

The server acts as a **pure facilitator**:

- ❌ **Never sees plaintext files** - only encrypted data
- ❌ **Never performs cryptographic operations** - clients handle all crypto
- ✅ **Stores encrypted file shares** and cryptographic artifacts
- ✅ **Manages access control** and user relationships
- ✅ **Facilitates key exchange** by serving public keys
- ✅ **Provides TOFU verification** for key authenticity

This design ensures that even if the server is compromised, user files remain protected by client-side encryption.
